# 数据管理指南

本指南详细说明了如何管理、配置和切换Ottawa GenAI Research Assistant原型中的Mock数据。

## 📚 目录

- [Mock数据概述](#mock数据概述)
- [数据结构详情](#数据结构详情)
- [用户认证数据管理](#用户认证数据管理)
- [如何切换Mock数据](#如何切换mock数据)
- [自定义Mock数据](#自定义mock数据)
- [数据更新策略](#数据更新策略)
- [调试和测试](#调试和测试)
- [迁移到后端API](#迁移到后端api)

## 🎯 Mock数据概述

Mock数据层位于 `ottawa-genai-prototype/src/mock/` 目录，提供完整的模拟数据集，支持原型的所有功能而无需真实后端。

### 📁 文件结构
```
ottawa-genai-prototype/src/mock/
├── api/
│   └── mockApi.ts           # Mock API 端点实现
├── data/                    # 所有Mock数据文件
│   ├── charts.ts           # 图表数据
│   ├── files.ts            # 文件上传数据
│   ├── messages.ts         # 聊天消息数据
│   ├── reports.ts          # 报告数据
│   ├── stats.ts            # 统计数据
│   ├── translations.ts     # 多语言翻译
│   └── index.ts            # 数据导出
├── types/
│   └── index.ts            # TypeScript类型定义
└── index.ts                # Mock层导出
```

## 📊 数据结构详情

### 1. 报告数据 (`reports.ts`)

```typescript
interface Report {
  id: string;                              // 唯一标识符
  title: string;                          // 报告标题
  generatedAt: Date;                      // 生成时间
  type: 'summary' | 'analysis' | 'trend'; // 报告类型
  status: 'completed' | 'processing' | 'error'; // 状态
}
```

**当前Mock数据**:
- Q1 2024 Economic Development Summary
- Small Business Growth Analysis  
- Employment Trends Report

**如何添加新报告**:
```typescript
export const mockReports: Report[] = [
  // ... 现有报告
  {
    id: '4', // 确保ID唯一
    title: 'Q2 2024 Technology Sector Analysis',
    generatedAt: new Date('2024-04-15'),
    type: 'analysis',
    status: 'completed'
  }
];
```

### 2. 聊天消息数据 (`messages.ts`)

```typescript
interface Message {
  id: string;           // 消息ID
  type: 'user' | 'assistant'; // 消息类型
  content: string;      // 消息内容
  timestamp: Date;      // 时间戳
  chart?: any;          // 可选图表数据
  hasChart?: boolean;   // 是否包含图表
}
```

**预设响应模式**:
- `business`: 商业增长分析
- `employment`: 就业趋势分析
- `default`: 默认帮助信息

**自定义AI响应**:
```typescript
export const mockResponsePatterns = {
  // 添加新的响应模式
  housing: {
    content: `## 住房市场分析
    
### 关键指标:
- **新建住房**: 增长12.5%
- **平均房价**: $485,000 (+3.2%)
- **租赁市场**: 空置率4.1%
    
### 趋势分析:
住房需求持续增长，特别是在科技走廊地区...`,
    hasChart: true,
    chart: [/* 住房数据 */]
  }
};
```

### 3. 文件上传数据 (`files.ts`)

```typescript
interface UploadedFile {
  id: string;                                    // 文件ID
  name: string;                                  // 文件名
  size: number;                                  // 文件大小(字节)
  type: string;                                  // MIME类型
  status: 'uploading' | 'completed' | 'error';  // 上传状态
  progress: number;                              // 上传进度(0-100)
  uploadedAt: Date;                             // 上传时间
}
```

**添加新文件**:
```typescript
export const mockUploadedFiles: UploadedFile[] = [
  // ... 现有文件
  {
    id: '3',
    name: 'Tourism Impact Study.pdf',
    size: 3200000,
    type: 'application/pdf',
    status: 'completed',
    progress: 100,
    uploadedAt: new Date('2024-02-01')
  }
];
```

### 4. 统计数据 (`stats.ts`)

```typescript
interface StatData {
  number: string;  // 统计数字
  label: string;   // 统计标签
}
```

**当前统计项**:
- 10+ Documents Processed
- 500+ Questions Answered
- 2 Languages Supported  
- 100% WCAG Compliant

### 5. 图表数据 (`charts.ts`)

包含多种可视化数据:

**商业增长数据**:
```typescript
businessGrowth: [
  { month: 'Jan', businesses: 120, growth: 5.2 },
  { month: 'Feb', businesses: 125, growth: 6.1 },
  // ...
]
```

**行业分析数据**:
```typescript
sectorAnalysis: [
  { sector: 'Technology', growth: 22, businesses: 145 },
  { sector: 'Healthcare', growth: 18, businesses: 98 },
  // ...
]
```

**就业分布数据**:
```typescript
employmentDistribution: [
  { name: 'Full-time', value: 65, color: '#667eea' },
  { name: 'Part-time', value: 25, color: '#10b981' },
  // ...
]
```

### 6. 多语言翻译 (`translations.ts`)

```typescript
interface Translations {
  [language: string]: {
    [key: string]: string;
  };
}
```

**支持语言**: English (en), Français (fr)

**添加新翻译**:
```typescript
export const mockTranslations: Translations = {
  en: {
    // ... 现有翻译
    'reports.new': 'New Report Generated',
    'analysis.complete': 'Analysis Complete'
  },
  fr: {
    // ... 现有翻译  
    'reports.new': 'Nouveau Rapport Généré',
    'analysis.complete': 'Analyse Terminée'
  }
};
```

## 🔐 用户认证数据管理

### 📋 **用户数据基础设施（认证就绪）**

渥太华GenAI研究助手已经在后端构建了完整的用户管理系统，为实施认证提供了坚实的基础。

#### **现有用户数据结构**

**位置：** `backend/monk/users/users.json`

```typescript
interface User {
  id: string;                              // 唯一用户标识符
  username: string;                        // 登录用户名
  email: string;                          // 用户邮箱地址
  role: 'researcher' | 'analyst' | 'admin'; // 用户角色
  status: 'active' | 'inactive' | 'suspended'; // 账户状态
  created_at: string;                     // 账户创建日期
  last_login?: string;                    // 最后登录时间戳
  preferences: {                          // 用户偏好设置
    language: 'en' | 'fr';               // 界面语言
    theme: 'light' | 'dark' | 'auto';    // 主题偏好
    notifications: boolean;               // 通知设置
    default_topics: string[];            // 默认研究主题
  };
  metadata: {                             // 用户元数据
    department?: string;                  // 用户部门
    access_level: 'standard' | 'advanced' | 'admin'; // 访问级别
  };
}
```

#### **预配置测试用户**

```json
[
  {
    "id": "user_001",
    "username": "john_researcher",
    "email": "john@ottawa.ca",
    "role": "researcher",
    "status": "active",
    "preferences": {
      "language": "en",
      "theme": "light",
      "default_topics": ["economic", "business"]
    },
    "metadata": {
      "department": "Economic Development",
      "access_level": "standard"
    }
  },
  {
    "id": "user_002",
    "username": "marie_analyst", 
    "email": "marie@ottawa.ca",
    "role": "analyst",
    "status": "active",
    "preferences": {
      "language": "fr",
      "theme": "dark",
      "default_topics": ["business", "innovation"]
    },
    "metadata": {
      "department": "Business Development",
      "access_level": "advanced"
    }
  },
  {
    "id": "user_003",
    "username": "admin_user",
    "email": "admin@ottawa.ca",
    "role": "admin", 
    "status": "active",
    "preferences": {
      "language": "en",
      "theme": "light",
      "default_topics": ["all"]
    },
    "metadata": {
      "department": "IT Services",
      "access_level": "admin"
    }
  }
]
```

### 🔑 **认证数据管理**

#### **会话管理（待实施）**

```typescript
interface UserSession {
  session_id: string;        // 唯一会话标识符
  user_id: string;          // 关联用户ID
  username: string;         // 用户名（快速访问）
  role: string;             // 用户角色（用于授权）
  created_at: Date;         // 会话创建时间
  expires_at: Date;         // 会话过期时间
  last_activity: Date;      // 最后活动时间戳
  is_active: boolean;       // 会话状态
}
```

#### **JWT令牌结构（计划中）**

```typescript
interface JWTPayload {
  sub: string;              // 主题（user_id）
  username: string;         // 用户名
  role: string;             // 用户角色
  access_level: string;     // 访问级别
  department?: string;      // 用户部门
  iat: number;              // 签发时间
  exp: number;              // 过期时间
}
```

### 🚀 **认证实施策略**

#### **阶段1：简单用户名认证**

**为快速部署，实施仅用户名认证：**

1. **登录流程：**
   ```typescript
   // 用户从可用用户下拉列表中选择
   const availableUsers = [
     { username: 'john_researcher', display: 'John（经济发展部）' },
     { username: 'marie_analyst', display: 'Marie（商业发展部）' },
     { username: 'admin_user', display: 'Admin（IT服务部）' }
   ];
   ```

2. **会话创建：**
   ```typescript
   // 用户选择后创建会话
   const session = {
     session_id: generateUUID(),
     user_id: selectedUser.id,
     username: selectedUser.username,
     role: selectedUser.role,
     created_at: new Date(),
     expires_at: new Date(Date.now() + 3600000), // 1小时
     is_active: true
   };
   ```

#### **阶段2：增强安全（未来）**

**为生产部署，添加密码认证：**

```typescript
interface UserCredentials {
  username: string;
  password_hash: string;    // bcrypt哈希密码
  salt: string;            // 密码盐值
  password_changed_at: Date; // 最后密码更改时间
  failed_login_attempts: number; // 失败登录计数器
  locked_until?: Date;     // 账户锁定过期时间
}
```

### 📊 **基于角色的数据访问**

#### **按角色的数据隔离：**

| 数据类型 | 研究员 | 分析师 | 管理员 |
|----------|-------|-------|-------|
| **自己的聊天历史** | ✅ 读/写 | ✅ 读/写 | ✅ 读/写 |
| **自己的文档** | ✅ 读/写 | ✅ 读/写 | ✅ 读/写 |
| **自己的报告** | ✅ 读/写 | ✅ 读/写 | ✅ 读/写 |
| **其他用户数据** | ❌ 无权限 | ❌ 无权限 | ✅ 只读 |
| **系统设置** | ❌ 无权限 | ❌ 无权限 | ✅ 读/写 |
| **用户管理** | ❌ 无权限 | ❌ 无权限 | ✅ 完全访问 |

#### **带用户关联的数据结构：**

```typescript
// 带用户上下文的聊天消息
interface ChatMessage {
  id: string;
  user_id: string;          // 关联用户
  conversation_id: string;   // 对话分组
  type: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  chart?: any;
}

// 带所有权的文档
interface Document {
  id: string;
  uploaded_by: string;      // 上传者用户ID
  filename: string;
  access_level: 'private' | 'department' | 'public';
  // ... 其他字段
}

// 带创建者跟踪的报告
interface Report {
  id: string;
  created_by: string;       // 创建者用户ID
  title: string;
  generated_at: Date;
  access_level: 'private' | 'department' | 'public';
  // ... 其他字段
}
```

### 🔧 **认证实施步骤**

#### **步骤1：更新后端用户服务**

```python
# backend/app/api/auth.py（新文件）
from fastapi import APIRouter, HTTPException, Depends
from app.services.auth_service import AuthService

router = APIRouter()

@router.post("/login")
async def login(username: str):
    # 阶段1的简化登录
    user = await auth_service.authenticate_user(username)
    if not user:
        raise HTTPException(status_code=401, detail="用户未找到")
    
    # 创建会话和JWT令牌
    token = await auth_service.create_token(user)
    return {"access_token": token, "token_type": "bearer", "user": user}
```

#### **步骤2：添加前端认证上下文**

```typescript
// frontend/src/contexts/AuthContext.tsx（新文件）
interface AuthContextType {
  user: User | null;
  login: (username: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
  isLoading: boolean;
}

export const AuthProvider: React.FC<{children: React.ReactNode}> = ({children}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // 认证逻辑实现
  // ...
};
```

#### **步骤3：保护路由**

```typescript
// frontend/src/components/ProtectedRoute.tsx（新文件）
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole?: string;
  requiredPermission?: string;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  children,
  requiredRole,
  requiredPermission
}) => {
  const { user, isAuthenticated } = useAuth();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }
  
  if (requiredRole && user?.role !== requiredRole) {
    return <div>访问被拒绝</div>;
  }
  
  return <>{children}</>;
};
```

### 🛡️ **安全最佳实践**

#### **会话安全：**
- **超时管理：** 60分钟会话，基于活动的续期
- **安全存储：** 会话令牌使用HTTPOnly cookies
- **CSRF保护：** 状态更改操作的反CSRF令牌
- **会话失效：** 适当的注销和会话清理

#### **数据保护：**
- **用户隔离：** 用户只能访问自己的数据
- **角色验证：** 所有操作的服务器端角色验证
- **审计日志：** 记录所有认证和授权事件
- **输入验证：** 清理所有用户输入

#### **政府合规：**
- **访问日志：** 为审计目的跟踪所有用户活动
- **数据保留：** 用户数据的可配置保留策略
- **隐私保护：** 不存储敏感个人信息
- **安全头：** 实施适当的HTTP安全头

## 🔄 如何切换Mock数据

### 1. 通过环境变量控制

```bash
# 使用Mock数据 (开发/演示)
export REACT_APP_API_STRATEGY=mock

# 混合模式 (开发阶段推荐)
export REACT_APP_API_STRATEGY=hybrid

# 真实API (生产环境)
export REACT_APP_API_STRATEGY=real
```

### 2. 动态数据切换

如果需要在运行时切换不同的Mock数据集:

```typescript
// 创建多个数据集
export const mockDataSets = {
  demo: {
    reports: demoReports,
    messages: demoMessages,
    stats: demoStats
  },
  development: {
    reports: devReports, 
    messages: devMessages,
    stats: devStats
  },
  testing: {
    reports: testReports,
    messages: testMessages,
    stats: testStats
  }
};

// 在mockApi.ts中根据环境选择数据集
const getCurrentDataSet = () => {
  const env = process.env.REACT_APP_MOCK_DATA_SET || 'demo';
  return mockDataSets[env] || mockDataSets.demo;
};
```

### 3. 时间基础的动态数据

创建基于时间的动态Mock数据:

```typescript
// 生成动态日期的报告
const generateDynamicReports = (): Report[] => {
  const now = new Date();
  return [
    {
      id: '1',
      title: `Q${Math.ceil((now.getMonth() + 1) / 3)} ${now.getFullYear()} Economic Summary`,
      generatedAt: new Date(now.getTime() - 24 * 60 * 60 * 1000), // 昨天
      type: 'summary',
      status: 'completed'
    }
    // ...
  ];
};
```

## ✨ 自定义Mock数据

### 1. 创建新的数据类型

1. **定义TypeScript接口** (`src/mock/types/index.ts`):
```typescript
export interface ProjectData {
  id: string;
  name: string;
  status: 'active' | 'completed' | 'pending';
  budget: number;
  startDate: Date;
  department: string;
}
```

2. **创建Mock数据文件** (`src/mock/data/projects.ts`):
```typescript
import { ProjectData } from '../types';

export const mockProjects: ProjectData[] = [
  {
    id: '1',
    name: 'Downtown Revitalization',
    status: 'active', 
    budget: 2500000,
    startDate: new Date('2024-01-01'),
    department: 'Urban Planning'
  }
  // ...
];
```

3. **添加API端点** (`src/mock/api/mockApi.ts`):
```typescript
import { mockProjects } from '../data/projects';

export const mockApi = {
  // ... 现有端点
  
  async getProjects(): Promise<ProjectData[]> {
    await delay(300);
    return mockProjects;
  },
  
  async getProject(id: string): Promise<ProjectData | null> {
    await delay(200);
    return mockProjects.find(p => p.id === id) || null;
  }
};
```

### 2. 高级Mock数据功能

**搜索和过滤**:
```typescript
async searchReports(query: string): Promise<Report[]> {
  await delay(400);
  return mockReports.filter(report => 
    report.title.toLowerCase().includes(query.toLowerCase())
  );
}
```

**分页支持**:
```typescript
async getReportsPaginated(page: number = 1, limit: number = 10): Promise<{
  reports: Report[];
  total: number;
  hasMore: boolean;
}> {
  await delay(500);
  const start = (page - 1) * limit;
  const end = start + limit;
  const reports = mockReports.slice(start, end);
  
  return {
    reports,
    total: mockReports.length,
    hasMore: end < mockReports.length
  };
}
```

**状态模拟**:
```typescript
async generateReport(type: string): Promise<Report> {
  const report: Report = {
    id: Date.now().toString(),
    title: `${type} Report - ${new Date().toLocaleDateString()}`,
    generatedAt: new Date(),
    type: type as any,
    status: 'processing'
  };
  
  // 模拟处理过程
  setTimeout(() => {
    report.status = 'completed';
  }, 3000);
  
  return report;
}
```

## 📈 数据更新策略

### 1. 实时数据模拟

```typescript
// 模拟实时统计更新
class MockDataManager {
  private updateInterval: NodeJS.Timeout;
  
  constructor() {
    this.startRealtimeUpdates();
  }
  
  private startRealtimeUpdates() {
    this.updateInterval = setInterval(() => {
      // 更新统计数据
      mockStats[0].number = `${Math.floor(Math.random() * 100) + 10}+`;
      mockStats[1].number = `${Math.floor(Math.random() * 1000) + 500}+`;
      
      // 触发更新事件
      window.dispatchEvent(new CustomEvent('mockDataUpdate'));
    }, 30000); // 每30秒更新
  }
  
  stopUpdates() {
    clearInterval(this.updateInterval);
  }
}
```

### 2. 用户交互响应

```typescript
// 根据用户操作更新数据
const simulateUserImpact = (action: string) => {
  switch (action) {
    case 'upload_file':
      mockStats[0].number = `${parseInt(mockStats[0].number) + 1}+`;
      break;
    case 'ask_question':
      mockStats[1].number = `${parseInt(mockStats[1].number) + 1}+`;
      break;
  }
};
```

## 🧪 调试和测试

### 1. Mock数据验证

```typescript
// 数据验证工具
const validateMockData = () => {
  const issues = [];
  
  // 检查ID唯一性
  const reportIds = mockReports.map(r => r.id);
  const uniqueIds = [...new Set(reportIds)];
  if (reportIds.length !== uniqueIds.length) {
    issues.push('Duplicate report IDs found');
  }
  
  // 检查必填字段
  mockReports.forEach(report => {
    if (!report.title || !report.id) {
      issues.push(`Invalid report: ${report.id}`);
    }
  });
  
  return issues;
};

// 在开发模式下运行验证
if (process.env.NODE_ENV === 'development') {
  const issues = validateMockData();
  if (issues.length > 0) {
    console.warn('Mock data issues:', issues);
  }
}
```

### 2. 数据导出工具

```typescript
// 导出Mock数据用于分析
const exportMockData = () => {
  const data = {
    reports: mockReports,
    files: mockUploadedFiles,
    stats: mockStats,
    translations: mockTranslations,
    timestamp: new Date().toISOString()
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], {
    type: 'application/json'
  });
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `mock-data-${Date.now()}.json`;
  a.click();
};
```

### 3. A/B测试支持

```typescript
// 支持不同版本的Mock数据
const getTestVariant = () => {
  const userId = localStorage.getItem('userId') || 'anonymous';
  const hash = userId.split('').reduce((a, b) => {
    a = ((a << 5) - a) + b.charCodeAt(0);
    return a & a;
  }, 0);
  
  return Math.abs(hash) % 2 === 0 ? 'A' : 'B';
};

const getMockDataForVariant = (variant: string) => {
  return variant === 'A' ? mockDataVariantA : mockDataVariantB;
};
```

## 🎛️ 配置选项

在 `.env` 文件中添加Mock数据配置:

```bash
# Mock数据配置
REACT_APP_API_STRATEGY=mock
REACT_APP_MOCK_DATA_SET=demo
REACT_APP_MOCK_DELAY_MIN=200
REACT_APP_MOCK_DELAY_MAX=800
REACT_APP_MOCK_ERROR_RATE=0.05
REACT_APP_ENABLE_MOCK_LOGS=true
```

在代码中使用配置:

```typescript
const mockConfig = {
  dataSet: process.env.REACT_APP_MOCK_DATA_SET || 'demo',
  delayMin: parseInt(process.env.REACT_APP_MOCK_DELAY_MIN || '200'),
  delayMax: parseInt(process.env.REACT_APP_MOCK_DELAY_MAX || '800'),
  errorRate: parseFloat(process.env.REACT_APP_MOCK_ERROR_RATE || '0'),
  enableLogs: process.env.REACT_APP_ENABLE_MOCK_LOGS === 'true'
};
```

## 🚀 最佳实践

### 1. 数据一致性
- 保持ID的唯一性
- 使用相同的日期格式
- 确保引用完整性

### 2. 性能优化
- 使用适当的延迟模拟真实网络
- 避免过大的Mock数据集
- 实现数据懒加载

### 3. 维护性
- 定期更新Mock数据
- 保持与真实API的一致性
- 添加数据版本控制

### 4. 测试覆盖
- 测试各种数据状态
- 模拟错误情况
- 验证边界条件

## 🔄 迁移到后端API

当原型开发完成，需要集成真实后端API时，Mock数据层的设计让迁移变得平滑和渐进。

### 1. API策略配置

项目支持三种API策略，可以逐步迁移：

```bash
# 1. 纯Mock模式 (原型阶段)
REACT_APP_API_STRATEGY=mock

# 2. 混合模式 (迁移阶段)
REACT_APP_API_STRATEGY=hybrid

# 3. 真实API模式 (生产阶段)
REACT_APP_API_STRATEGY=real
```

### 2. 渐进式迁移步骤

#### Step 1: 建立API契约

首先基于Mock数据定义真实API的接口规范：

```typescript
// src/api/types.ts - API契约定义
export interface ApiReport {
  id: string;
  title: string;
  generatedAt: string; // ISO 8601格式
  type: 'summary' | 'analysis' | 'trend';
  status: 'completed' | 'processing' | 'error';
}

export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
  timestamp: string;
}
```

#### Step 2: 创建API适配器

```typescript
// src/api/realApi.ts - 真实API实现
export class RealApiService {
  private baseUrl = process.env.REACT_APP_API_BASE_URL;
  
  async getReports(): Promise<ApiResponse<ApiReport[]>> {
    const response = await fetch(`${this.baseUrl}/api/reports`, {
      headers: {
        'Authorization': `Bearer ${this.getToken()}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response.json();
  }
  
  async generateReport(type: string): Promise<ApiResponse<ApiReport>> {
    const response = await fetch(`${this.baseUrl}/api/reports/generate`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.getToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ type })
    });
    
    return response.json();
  }
  
  private getToken(): string {
    return localStorage.getItem('auth_token') || '';
  }
}
```

#### Step 3: 创建统一服务层

```typescript
// src/services/dataService.ts - 统一数据服务
import { mockApi } from '../mock/api/mockApi';
import { RealApiService } from '../api/realApi';

export class DataService {
  private mockApi = mockApi;
  private realApi = new RealApiService();
  private strategy = process.env.REACT_APP_API_STRATEGY || 'mock';
  
  async getReports(): Promise<Report[]> {
    try {
      switch (this.strategy) {
        case 'mock':
          return await this.mockApi.getReports();
          
        case 'real':
          const response = await this.realApi.getReports();
          return this.transformApiReports(response.data);
          
        case 'hybrid':
          try {
            const response = await this.realApi.getReports();
            return this.transformApiReports(response.data);
          } catch (error) {
            console.warn('API failed, falling back to mock:', error);
            return await this.mockApi.getReports();
          }
          
        default:
          return await this.mockApi.getReports();
      }
    } catch (error) {
      if (this.strategy === 'hybrid') {
        console.warn('Using mock fallback due to error:', error);
        return await this.mockApi.getReports();
      }
      throw error;
    }
  }
  
  private transformApiReports(apiReports: ApiReport[]): Report[] {
    return apiReports.map(apiReport => ({
      id: apiReport.id,
      title: apiReport.title,
      generatedAt: new Date(apiReport.generatedAt),
      type: apiReport.type,
      status: apiReport.status
    }));
  }
}

// 创建单例实例
export const dataService = new DataService();
```

### 3. 迁移检查清单

#### 🔍 迁移前检查
- [ ] API端点是否已定义并可访问
- [ ] 认证机制是否已实现
- [ ] 数据格式是否与Mock数据兼容
- [ ] 错误处理是否完善
- [ ] 网络超时配置是否合理

#### 🧪 测试步骤
1. **混合模式测试**: 设置`REACT_APP_API_STRATEGY=hybrid`
2. **API可用性测试**: 验证所有端点正常工作
3. **错误场景测试**: 测试网络断开、服务器错误等情况
4. **性能测试**: 比较Mock和真实API的响应时间
5. **数据一致性测试**: 确保API返回数据格式正确

#### 🚀 上线步骤
1. **阶段1**: 在开发环境使用混合模式
2. **阶段2**: 在测试环境使用真实API
3. **阶段3**: 逐步在生产环境切换模块
4. **阶段4**: 完全切换到真实API
5. **阶段5**: 移除Mock代码(可选)

---

通过这个指南，你可以完全控制Mock数据的行为，创建丰富的原型体验，并为向真实API的迁移做好准备。 