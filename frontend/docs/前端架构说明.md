# 🎨 渥太华生成式AI研究助手 - 前端架构说明

## 📊 前端架构概览

本前端应用采用现代React架构，结合TypeScript提供类型安全，支持英法双语，遵循WCAG 2.1无障碍标准。架构设计注重组件复用、状态管理和用户体验优化。

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户界面层 (React Components)                 │
│                    - 页面组件 (Pages)                           │
│                    - 通用组件 (Components)                      │
│                    - 样式系统 (CSS Modules)                     │
└─────────────────────────┬───────────────────────────────────────┘
                          │ Props & Events
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                    状态管理层 (Context API)                     │
│                    - 语言上下文 (LanguageContext)               │
│                    - 主题上下文 (ThemeContext)                  │
│                    - 用户状态管理                               │
└─────────────────────────┬───────────────────────────────────────┘
                          │ State Updates
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                    服务层 (Services)                           │
│                    - API服务 (api.ts)                          │
│                    - 混合API (hybridApi.ts)                    │
│                    - 数据转换处理                               │
└─────────────────────────┬───────────────────────────────────────┘
                          │ HTTP Requests
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                    后端接口层 (FastAPI)                        │
│                    - RESTful API端点                           │
│                    - Mock数据接口                              │
│                    - 实时通信支持                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🗂️ 前端目录结构详解

```
frontend/
├── public/               # 静态资源目录
│   ├── index.html       # HTML模板
│   ├── favicon.ico      # 网站图标
│   └── manifest.json    # PWA配置
├── src/                 # 源代码目录
│   ├── components/      # 可复用组件
│   │   ├── Navbar.tsx          # 导航栏组件
│   │   └── Navbar.css          # 导航栏样式
│   ├── pages/          # 页面组件
│   │   ├── HomePage.tsx        # 首页
│   │   ├── ChatPage.tsx        # 聊天页面
│   │   ├── DocumentUploadPage.tsx  # 文档上传页面
│   │   ├── ReportPage.tsx      # 报告页面
│   │   ├── SettingsPage.tsx    # 设置页面
│   │   ├── MockDataManagePage.tsx  # Mock数据管理页面
│   │   └── *.css              # 对应的样式文件
│   ├── services/       # 服务层
│   │   ├── api.ts             # 标准API服务
│   │   └── hybridApi.ts       # 混合API服务
│   ├── config/         # 配置文件
│   ├── mock/           # Mock数据
│   ├── App.tsx         # 应用根组件
│   ├── App.css         # 全局样式
│   ├── index.tsx       # 应用入口
│   └── index.css       # 基础样式
├── docs/               # 项目文档
├── package.json        # 项目配置
├── tsconfig.json       # TypeScript配置
├── Dockerfile         # Docker配置
└── README.md          # 项目说明
```

## ⚛️ React组件架构

### 1. 页面组件 (Pages)
页面组件负责整个页面的布局和主要功能实现：

#### HomePage - 首页
```typescript
// 首页展示系统介绍和快速入口
const HomePage: React.FC = () => {
  const { t } = useLanguage();
  
  return (
    <div className="home-container">
      <WelcomeSection />
      <FeatureCards />
      <QuickActions />
    </div>
  );
};
```

#### ChatPage - 聊天页面
```typescript
// 核心聊天交互功能
const ChatPage: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  
  const handleSendMessage = async (content: string) => {
    // 发送消息逻辑
    const response = await hybridApi.sendMessage(content);
    setMessages(prev => [...prev, response]);
  };
  
  return (
    <div className="chat-container">
      <MessageList messages={messages} />
      <MessageInput onSend={handleSendMessage} disabled={isLoading} />
    </div>
  );
};
```

#### DocumentUploadPage - 文档上传页面
```typescript
// 文档上传和管理功能
const DocumentUploadPage: React.FC = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [uploadProgress, setUploadProgress] = useState<number>(0);
  
  const handleFileUpload = async (files: FileList) => {
    // 文件上传逻辑
    for (const file of files) {
      await api.uploadDocument(file, {
        onProgress: setUploadProgress
      });
    }
    refreshDocuments();
  };
  
  return (
    <div className="upload-container">
      <DropZone onDrop={handleFileUpload} />
      <DocumentList documents={documents} />
    </div>
  );
};
```

### 2. 通用组件 (Components)

#### Navbar - 导航栏
```typescript
// 响应式导航栏组件
const Navbar: React.FC = () => {
  const { language, setLanguage, t } = useLanguage();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  
  return (
    <nav className="navbar" role="navigation" aria-label="主导航">
      <div className="navbar-brand">
        <Link to="/" aria-label={t('nav.home')}>
          <img src="/logo.svg" alt="Ottawa Logo" />
        </Link>
      </div>
      
      <div className="navbar-menu">
        <NavigationLinks />
        <LanguageToggle 
          current={language} 
          onChange={setLanguage}
        />
      </div>
    </nav>
  );
};
```

## 🌐 国际化架构 (i18n)

### 语言上下文管理
```typescript
// 语言上下文定义
interface LanguageContextType {
  language: 'en' | 'fr';
  setLanguage: (lang: 'en' | 'fr') => void;
  t: (key: string) => string;
}

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

// 翻译数据结构
const translations = {
  en: {
    'app.title': 'Ottawa GenAI Research Assistant',
    'nav.home': 'Home',
    'nav.chat': 'Chat',
    'features.qa.title': 'Natural Language Q&A',
    // ... 更多英文翻译
  },
  fr: {
    'app.title': 'Assistant de Recherche GenAI d\'Ottawa',
    'nav.home': 'Accueil',
    'nav.chat': 'Chat',
    'features.qa.title': 'Q&R en Langage Naturel',
    // ... 更多法文翻译
  }
};

// 翻译函数实现
const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
};
```

### 语言切换功能
```typescript
// 语言切换组件
const LanguageToggle: React.FC<{
  current: 'en' | 'fr';
  onChange: (lang: 'en' | 'fr') => void;
}> = ({ current, onChange }) => {
  return (
    <div className="language-toggle" role="group" aria-label="语言选择">
      <button
        className={current === 'en' ? 'active' : ''}
        onClick={() => onChange('en')}
        aria-pressed={current === 'en'}
      >
        EN
      </button>
      <button
        className={current === 'fr' ? 'active' : ''}
        onClick={() => onChange('fr')}
        aria-pressed={current === 'fr'}
      >
        FR
      </button>
    </div>
  );
};
```

## 🔌 API服务架构

### 标准API服务 (api.ts)
```typescript
// 标准的RESTful API调用
class ApiService {
  private baseURL = process.env.REACT_APP_API_URL || 'http://localhost:8000';
  
  async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      headers: {
        'Content-Type': 'application/json',
        'Accept-Language': this.getCurrentLanguage(),
      },
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    
    return response.json();
  }
  
  async post<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept-Language': this.getCurrentLanguage(),
      },
      body: JSON.stringify(data),
    });
    
    return this.handleResponse<T>(response);
  }
  
  // 文档上传
  async uploadDocument(file: File, options?: {
    onProgress?: (progress: number) => void;
  }): Promise<DocumentResponse> {
    const formData = new FormData();
    formData.append('file', file);
    
    return this.uploadWithProgress('/documents/upload', formData, options);
  }
  
  // 聊天消息发送
  async sendChatMessage(message: string): Promise<ChatResponse> {
    return this.post('/chat/send', { message });
  }
}

export const api = new ApiService();
```

### 混合API服务 (hybridApi.ts)
```typescript
// 支持Mock数据和真实API的混合服务
class HybridApiService {
  private useMockData = process.env.REACT_APP_USE_MOCK === 'true';
  private apiService = new ApiService();
  
  async sendMessage(content: string): Promise<ChatMessage> {
    if (this.useMockData) {
      // 使用Mock数据进行快速原型开发
      return this.generateMockResponse(content);
    } else {
      // 调用真实的后端API
      return this.apiService.sendChatMessage(content);
    }
  }
  
  private generateMockResponse(input: string): ChatMessage {
    // 智能Mock响应生成
    const mockResponses = {
      economic: "根据渥太华经济发展数据，2023年科技行业增长了15%...",
      investment: "最新的投资趋势显示，清洁技术领域获得了显著关注...",
      default: "感谢您的问题。基于可用数据，我可以为您提供以下分析..."
    };
    
    const responseType = this.categorizeInput(input);
    return {
      id: Date.now().toString(),
      content: mockResponses[responseType] || mockResponses.default,
      type: 'assistant',
      timestamp: new Date(),
      metadata: {
        charts: this.generateMockCharts(responseType),
        sources: this.generateMockSources(responseType)
      }
    };
  }
}

export const hybridApi = new HybridApiService();
```

## 🎨 样式架构

### CSS模块化策略
每个组件都有对应的CSS文件，采用BEM命名规范：

```css
/* HomePage.css */
.home-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
}

.home__hero {
  text-align: center;
  margin-bottom: 4rem;
}

.home__hero-title {
  font-size: 3rem;
  font-weight: 700;
  color: var(--primary-color);
  margin-bottom: 1rem;
}

.home__features {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
  margin-bottom: 4rem;
}

.home__feature-card {
  background: var(--card-background);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: var(--card-shadow);
  transition: transform 0.2s ease;
}

.home__feature-card:hover {
  transform: translateY(-4px);
}
```

### 响应式设计
```css
/* 移动端适配 */
@media (max-width: 768px) {
  .home__hero-title {
    font-size: 2rem;
  }
  
  .home__features {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .navbar__menu {
    display: none;
  }
  
  .navbar__mobile-toggle {
    display: block;
  }
}

/* 大屏幕优化 */
@media (min-width: 1440px) {
  .home-container {
    max-width: 1400px;
  }
  
  .home__features {
    grid-template-columns: repeat(4, 1fr);
  }
}
```

## ♿ 无障碍设计 (WCAG 2.1)

### 语义化HTML结构
```typescript
// 正确使用ARIA标签和语义化元素
const ChatPage: React.FC = () => {
  return (
    <main role="main" aria-label="聊天界面">
      <section aria-label="消息历史">
        <h2 className="sr-only">聊天消息</h2>
        <div 
          role="log" 
          aria-live="polite" 
          aria-label="聊天消息列表"
          className="messages-container"
        >
          {messages.map(message => (
            <div 
              key={message.id}
              role="article"
              aria-label={`${message.type === 'user' ? '用户' : '助手'}消息`}
              className={`message message--${message.type}`}
            >
              {message.content}
            </div>
          ))}
        </div>
      </section>
      
      <section aria-label="消息输入">
        <form onSubmit={handleSubmit} role="form">
          <label htmlFor="message-input" className="sr-only">
            输入您的问题
          </label>
          <input
            id="message-input"
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder="输入您的问题..."
            aria-describedby="input-help"
            required
          />
          <div id="input-help" className="sr-only">
            按回车键发送消息，支持英文和法文
          </div>
          <button 
            type="submit" 
            aria-label="发送消息"
            disabled={isLoading}
          >
            {isLoading ? '发送中...' : '发送'}
          </button>
        </form>
      </section>
    </main>
  );
};
```

### 键盘导航支持
```typescript
// 键盘快捷键支持
const useKeyboardShortcuts = () => {
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Ctrl/Cmd + K 打开搜索
      if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
        event.preventDefault();
        // 打开搜索对话框
      }
      
      // ESC 关闭对话框
      if (event.key === 'Escape') {
        // 关闭当前模态框
      }
      
      // Tab 导航支持
      if (event.key === 'Tab') {
        // 确保焦点可见
        document.body.classList.add('keyboard-navigation');
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);
};
```

## 📱 响应式架构

### 移动优先设计
```typescript
// 响应式Hook
const useResponsive = () => {
  const [screenSize, setScreenSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });
  
  const [device, setDevice] = useState<'mobile' | 'tablet' | 'desktop'>('desktop');
  
  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      setScreenSize({
        width,
        height: window.innerHeight,
      });
      
      if (width < 768) {
        setDevice('mobile');
      } else if (width < 1024) {
        setDevice('tablet');
      } else {
        setDevice('desktop');
      }
    };
    
    window.addEventListener('resize', handleResize);
    handleResize(); // 初始化
    
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return { screenSize, device };
};
```

### 自适应组件
```typescript
// 响应式导航组件
const ResponsiveNavbar: React.FC = () => {
  const { device } = useResponsive();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  
  if (device === 'mobile') {
    return (
      <MobileNavbar 
        isOpen={mobileMenuOpen}
        onToggle={setMobileMenuOpen}
      />
    );
  }
  
  return <DesktopNavbar />;
};
```

## 🚀 性能优化策略

### 1. 代码分割 (Code Splitting)
```typescript
// 路由级别的懒加载
const HomePage = lazy(() => import('./pages/HomePage'));
const ChatPage = lazy(() => import('./pages/ChatPage'));
const DocumentUploadPage = lazy(() => import('./pages/DocumentUploadPage'));

const App: React.FC = () => {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/chat" element={<ChatPage />} />
          <Route path="/upload" element={<DocumentUploadPage />} />
        </Routes>
      </Suspense>
    </Router>
  );
};
```

### 2. 组件优化
```typescript
// React.memo 优化重渲染
const MessageItem = React.memo<{
  message: ChatMessage;
  onEdit?: (id: string) => void;
}>(({ message, onEdit }) => {
  return (
    <div className="message-item">
      <div className="message-content">{message.content}</div>
      {onEdit && (
        <button onClick={() => onEdit(message.id)}>
          编辑
        </button>
      )}
    </div>
  );
});

// useCallback 优化函数引用
const ChatPage: React.FC = () => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  
  const handleSendMessage = useCallback(async (content: string) => {
    const newMessage = await api.sendMessage(content);
    setMessages(prev => [...prev, newMessage]);
  }, []);
  
  const handleEditMessage = useCallback((id: string) => {
    // 编辑消息逻辑
  }, []);
  
  return (
    <div>
      {messages.map(message => (
        <MessageItem
          key={message.id}
          message={message}
          onEdit={handleEditMessage}
        />
      ))}
    </div>
  );
};
```

### 3. 虚拟滚动
```typescript
// 长列表虚拟滚动优化
const VirtualizedMessageList: React.FC<{
  messages: ChatMessage[];
}> = ({ messages }) => {
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 50 });
  const containerRef = useRef<HTMLDivElement>(null);
  
  const handleScroll = useCallback(() => {
    if (!containerRef.current) return;
    
    const { scrollTop, clientHeight } = containerRef.current;
    const itemHeight = 100; // 预估消息高度
    
    const start = Math.floor(scrollTop / itemHeight);
    const end = Math.min(
      start + Math.ceil(clientHeight / itemHeight) + 5,
      messages.length
    );
    
    setVisibleRange({ start, end });
  }, [messages.length]);
  
  const visibleMessages = messages.slice(visibleRange.start, visibleRange.end);
  
  return (
    <div
      ref={containerRef}
      className="message-list"
      onScroll={handleScroll}
      style={{ height: '400px', overflowY: 'auto' }}
    >
      <div style={{ height: visibleRange.start * 100 }} />
      {visibleMessages.map(message => (
        <MessageItem key={message.id} message={message} />
      ))}
      <div style={{ height: (messages.length - visibleRange.end) * 100 }} />
    </div>
  );
};
```

## 🧪 测试架构

### 组件测试策略
```typescript
// HomePage.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import HomePage from './HomePage';
import { LanguageProvider } from '../contexts/LanguageContext';

const renderWithProviders = (component: React.ReactElement) => {
  return render(
    <BrowserRouter>
      <LanguageProvider>
        {component}
      </LanguageProvider>
    </BrowserRouter>
  );
};

describe('HomePage', () => {
  test('renders welcome message', () => {
    renderWithProviders(<HomePage />);
    expect(screen.getByText(/Ottawa Economic Development/)).toBeInTheDocument();
  });
  
  test('language switching works', () => {
    renderWithProviders(<HomePage />);
    
    const frenchButton = screen.getByText('FR');
    fireEvent.click(frenchButton);
    
    expect(screen.getByText(/Développement Économique/)).toBeInTheDocument();
  });
  
  test('navigation links are accessible', () => {
    renderWithProviders(<HomePage />);
    
    const chatLink = screen.getByRole('link', { name: /chat/i });
    expect(chatLink).toHaveAttribute('href', '/chat');
  });
});
```

### API服务测试
```typescript
// api.test.ts
import { api } from './api';

// Mock fetch
global.fetch = jest.fn();

describe('ApiService', () => {
  beforeEach(() => {
    (fetch as jest.Mock).mockClear();
  });
  
  test('sends chat message correctly', async () => {
    const mockResponse = {
      id: '1',
      content: 'Test response',
      type: 'assistant'
    };
    
    (fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    });
    
    const result = await api.sendChatMessage('Hello');
    
    expect(fetch).toHaveBeenCalledWith(
      'http://localhost:8000/chat/send',
      expect.objectContaining({
        method: 'POST',
        body: JSON.stringify({ message: 'Hello' }),
      })
    );
    
    expect(result).toEqual(mockResponse);
  });
});
```

## 🔧 开发工具配置

### TypeScript配置
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"],
      "@/components/*": ["components/*"],
      "@/pages/*": ["pages/*"],
      "@/services/*": ["services/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}
```

### Docker配置
```dockerfile
# Dockerfile
FROM node:18-alpine as build

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .

# Build application
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## 🎯 架构优势

### 1. 🧩 模块化设计
- **组件复用性高**: 通用组件可在多个页面使用
- **代码可维护性强**: 清晰的文件结构和命名规范
- **功能扩展便利**: 新功能可以独立开发和测试

### 2. 🌐 国际化支持
- **完整双语支持**: 英语和法语无缝切换
- **动态语言加载**: 按需加载翻译文件
- **文化本地化**: 支持不同地区的格式差异

### 3. ♿ 无障碍优先
- **WCAG 2.1兼容**: 符合最新无障碍标准
- **键盘导航**: 完整的键盘操作支持
- **屏幕阅读器友好**: 正确的ARIA标签使用

### 4. 📱 响应式优化
- **移动优先**: 从小屏幕开始设计
- **自适应布局**: 适应各种设备尺寸
- **触摸友好**: 优化移动设备交互

### 5. ⚡ 性能优化
- **代码分割**: 减少初始加载时间
- **懒加载**: 按需加载组件和资源
- **虚拟滚动**: 处理大量数据展示

## 🚀 运行和部署

### 开发环境启动
```bash
cd frontend
npm install
npm start
```

### 生产构建
```bash
npm run build
```

### Docker部署
```bash
docker build -t ottawa-genai-frontend .
docker run -p 80:80 ottawa-genai-frontend
```

## 📝 开发最佳实践

### 1. 组件开发规范
- 使用TypeScript进行类型定义
- 遵循React Hooks最佳实践
- 实现适当的错误边界
- 编写单元测试

### 2. 样式规范
- 使用CSS变量定义主题
- 遵循BEM命名规范
- 实现响应式设计
- 优化CSS性能

### 3. 状态管理
- 合理使用Context API
- 避免不必要的重渲染
- 实现适当的缓存策略
- 处理异步状态

### 4. 测试策略
- 编写组件单元测试
- 实现集成测试
- 进行无障碍测试
- 性能测试和优化

## 🔄 未来扩展计划

### 1. PWA支持
- 离线功能支持
- 消息推送
- 安装到主屏幕

### 2. 高级功能
- 实时协作
- 语音输入
- 高级图表组件
- 数据可视化

### 3. 技术升级
- React 18特性充分利用
- 新的状态管理方案
- 更好的构建工具
- 性能监控集成

这个前端架构确保了应用的可扩展性、可维护性和用户体验的优化，同时满足了渥太华市政府对双语支持和无障碍访问的要求。 