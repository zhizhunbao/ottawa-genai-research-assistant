---
description: Create implementation plan before coding - WAIT for user CONFIRM before touching any code
---

# Plan Command

在写代码之前创建完整的实现计划。**必须等待用户确认后才能开始编码。**

## 何时使用

使用 `/plan` 当：

- 开始新功能开发
- 进行重大架构变更
- 复杂的重构工作
- 多个文件/组件会受影响
- 需求不明确或有歧义

## 规划流程

### 1. 需求重述

- 用清晰的术语重新表述需求
- 确认理解正确
- 列出假设和约束

### 2. 分解为阶段

- 将实现分解为具体、可操作的步骤
- 识别组件之间的依赖关系
- 评估每个阶段的风险

### 3. 评估复杂度

- High/Medium/Low
- 估算每个阶段的时间

### 4. 等待确认

- **关键**：在用户明确确认前不写任何代码
- 用户可以修改、调整或拒绝计划

## 计划格式模板

```markdown
# 实现计划: [功能名称]

## 概述

[2-3 句话概述]

## 需求重述

- [需求 1]
- [需求 2]

## 实现阶段

### 阶段 1: [阶段名称]

1. **[步骤名称]** (文件: path/to/file)
   - 操作: 具体操作
   - 原因: 为什么这样做
   - 依赖: 无 / 依赖步骤 X
   - 风险: Low/Medium/High

### 阶段 2: [阶段名称]

...

## 测试策略

- 单元测试: [需要测试的文件]
- 集成测试: [需要测试的流程]
- E2E 测试: [需要测试的用户旅程]

## 风险与缓解

- **风险**: [描述]
  - 缓解: [如何解决]

## 成功标准

- [ ] 标准 1
- [ ] 标准 2

## 估算复杂度: [HIGH/MEDIUM/LOW]

- 后端: X-Y 小时
- 前端: X-Y 小时
- 测试: X-Y 小时
- 总计: X-Y 小时

**等待确认**: 是否按此计划执行？(yes/no/modify)
```

## 最佳实践

1. **具体明确**: 使用确切的文件路径、函数名、变量名
2. **考虑边界情况**: 错误场景、空值、边界条件
3. **最小化变更**: 优先扩展现有代码而非重写
4. **遵循现有模式**: 保持项目一致性
5. **便于测试**: 结构化变更以便于测试
6. **增量可验证**: 每个步骤都应该可以验证
7. **记录决策**: 解释为什么，而不仅仅是做什么

## 重构时的检查点

1. 识别代码异味和技术债务
2. 列出具体改进点
3. 保留现有功能
4. 创建向后兼容的变更
5. 规划渐进式迁移

## 危险信号检查

- 大函数 (>50 行)
- 深嵌套 (>4 层)
- 重复代码
- 缺少错误处理
- 硬编码值
- 缺少测试
- 性能瓶颈

---

**记住**: 好的计划是具体的、可操作的，并且同时考虑正常路径和边界情况。最好的计划能让你自信地、增量地实现功能。
