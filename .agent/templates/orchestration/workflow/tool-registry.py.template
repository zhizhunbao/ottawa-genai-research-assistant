"""
Tool Registry - Dynamic tool registration and schema validation.

@module orchestration/workflow/tool-registry
@source dify/api/core/tools/tool_manager.py (tool management)
@reference https://github.com/langgenius/dify
@template S4-M4-F3

Tool registry pattern:
1. Register tools with name, description, and JSON Schema parameters
2. Validate tool call arguments against schema
3. Execute tools by name with validated inputs
4. Generate OpenAI-compatible function definitions for LLM
"""

from __future__ import annotations

import json
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Callable, Awaitable

logger = logging.getLogger(__name__)


# ─── Types ───────────────────────────────────────────────────────────────────

@dataclass
class ToolParameter:
    """Definition for a single tool parameter."""
    name: str
    type: str  # "string" | "number" | "boolean" | "array" | "object"
    description: str = ""
    required: bool = False
    enum: list[str] | None = None
    default: Any = None


@dataclass
class ToolDefinition:
    """Complete tool definition with metadata and parameters."""
    name: str
    description: str
    parameters: list[ToolParameter] = field(default_factory=list)
    category: str = "general"
    is_async: bool = True


@dataclass
class ToolCallResult:
    """Result from a tool execution."""
    name: str
    success: bool
    output: Any = None
    error: str | None = None


# ─── Tool Interface ─────────────────────────────────────────────────────────

class Tool(ABC):
    """Abstract base class for tools."""
    
    @property
    @abstractmethod
    def definition(self) -> ToolDefinition:
        """Return the tool's definition."""
        ...
    
    @abstractmethod
    async def execute(self, **kwargs) -> Any:
        """Execute the tool with validated parameters."""
        ...


# ─── Tool Registry ──────────────────────────────────────────────────────────
# @source dify/api/core/tools/tool_manager.py

class ToolRegistry:
    """
    Registry for managing and executing tools.
    
    @example
    registry = ToolRegistry()
    registry.register(MySearchTool())
    
    # Or register a simple function:
    registry.register_function(
        name="calculate",
        description="Evaluate a math expression",
        parameters=[ToolParameter("expression", "string", "Math expression", required=True)],
        fn=lambda expression: eval(expression),
    )
    
    # Execute
    result = await registry.call("calculate", expression="2 + 2")
    
    # Get OpenAI function definitions
    functions = registry.to_openai_functions()
    """
    
    def __init__(self):
        self._tools: dict[str, Tool] = {}
        self._functions: dict[str, tuple[ToolDefinition, Callable]] = {}
    
    def register(self, tool: Tool) -> None:
        """Register a Tool class instance."""
        defn = tool.definition
        self._tools[defn.name] = tool
        logger.info(f"Registered tool: {defn.name}")
    
    def register_function(
        self,
        name: str,
        description: str,
        parameters: list[ToolParameter],
        fn: Callable[..., Any] | Callable[..., Awaitable[Any]],
        category: str = "general",
    ) -> None:
        """Register a plain function as a tool."""
        defn = ToolDefinition(
            name=name,
            description=description,
            parameters=parameters,
            category=category,
        )
        self._functions[name] = (defn, fn)
        logger.info(f"Registered function tool: {name}")
    
    def list_tools(self) -> list[ToolDefinition]:
        """List all registered tool definitions."""
        definitions = []
        for tool in self._tools.values():
            definitions.append(tool.definition)
        for defn, _ in self._functions.values():
            definitions.append(defn)
        return definitions
    
    def get_tool(self, name: str) -> Tool | None:
        """Get a tool by name."""
        return self._tools.get(name)
    
    async def call(self, name: str, **kwargs) -> ToolCallResult:
        """
        Execute a tool by name with the given arguments.
        Validates parameters before execution.
        """
        try:
            # Check Tool instances first
            if name in self._tools:
                tool = self._tools[name]
                defn = tool.definition
                validated = self._validate_params(defn, kwargs)
                output = await tool.execute(**validated)
                return ToolCallResult(name=name, success=True, output=output)
            
            # Check function tools
            if name in self._functions:
                defn, fn = self._functions[name]
                validated = self._validate_params(defn, kwargs)
                
                import asyncio
                if asyncio.iscoroutinefunction(fn):
                    output = await fn(**validated)
                else:
                    output = fn(**validated)
                
                return ToolCallResult(name=name, success=True, output=output)
            
            return ToolCallResult(
                name=name, success=False, error=f"Tool not found: {name}"
            )
        
        except Exception as e:
            return ToolCallResult(name=name, success=False, error=str(e))
    
    def _validate_params(
        self, defn: ToolDefinition, kwargs: dict[str, Any]
    ) -> dict[str, Any]:
        """Validate and coerce parameters against the tool definition."""
        validated = {}
        
        for param in defn.parameters:
            if param.name in kwargs:
                value = kwargs[param.name]
                # Basic type coercion
                if param.type == "number" and isinstance(value, str):
                    value = float(value)
                elif param.type == "boolean" and isinstance(value, str):
                    value = value.lower() in ("true", "1", "yes")
                
                # Enum validation
                if param.enum and str(value) not in param.enum:
                    raise ValueError(
                        f"Parameter '{param.name}' must be one of {param.enum}"
                    )
                validated[param.name] = value
                
            elif param.required:
                raise ValueError(f"Missing required parameter: '{param.name}'")
            elif param.default is not None:
                validated[param.name] = param.default
        
        return validated
    
    # ── OpenAI Function Calling Integration ──────────────────────────────
    
    def to_openai_functions(self) -> list[dict]:
        """
        Convert all tools to OpenAI function calling format.
        Compatible with OpenAI's tools parameter.
        """
        functions = []
        for defn in self.list_tools():
            functions.append(self._defn_to_openai(defn))
        return functions
    
    @staticmethod
    def _defn_to_openai(defn: ToolDefinition) -> dict:
        """Convert a ToolDefinition to OpenAI function format."""
        properties = {}
        required = []
        
        for param in defn.parameters:
            prop: dict[str, Any] = {"type": param.type, "description": param.description}
            if param.enum:
                prop["enum"] = param.enum
            properties[param.name] = prop
            if param.required:
                required.append(param.name)
        
        return {
            "type": "function",
            "function": {
                "name": defn.name,
                "description": defn.description,
                "parameters": {
                    "type": "object",
                    "properties": properties,
                    "required": required,
                },
            },
        }
    
    def from_openai_tool_call(
        self, tool_call: dict
    ) -> tuple[str, dict[str, Any]]:
        """
        Parse an OpenAI tool call response into (name, arguments).
        """
        function = tool_call.get("function", {})
        name = function.get("name", "")
        args_str = function.get("arguments", "{}")
        
        try:
            args = json.loads(args_str)
        except json.JSONDecodeError:
            args = {}
        
        return name, args
