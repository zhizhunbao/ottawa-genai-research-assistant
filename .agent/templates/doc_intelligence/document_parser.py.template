from abc import ABC, abstractmethod
from enum import StrEnum
from typing import List, Dict, Any, Optional, Callable
from pydantic import BaseModel, Field

class ParseMethod(StrEnum):
    """
    解析策略分类
    出处: RAGFlow (https://github.com/infiniflow/ragflow)
    参考: .github/references/ragflow/rag/app/naive.py
    """
    DEEPDOC = "deepdoc"       # RAGFlow 内置：OCR + 布局识别 + 表格结构识别
    MINERU = "mineru"         # MinerU 学术论文解析
    DOCLING = "docling"       # IBM Docling
    PADDLEOCR = "paddleocr"   # PaddleOCR 中文优化
    NAIVE = "naive"           # 纯文本解析 fallback

class Chunk(BaseModel):
    """
    文档切分块.
    """
    content: str
    page_number: int
    metadata: Dict[str, Any] = Field(default_factory=dict)
    position: Optional[List[float]] = None # [x0, y0, x1, y1] 坐标

class ParseResult(BaseModel):
    """
    H1. 解析结果统一模型.
    出处: RAGFlow (https://github.com/infiniflow/ragflow)
    参考: .github/references/ragflow/deepdoc/
    """
    chunks: List[Chunk]        # 文本块
    tables: List[Dict[str, Any]] = Field(default_factory=list)  # 表格 (裁剪图像 + 自然语言描述)
    figures: List[Dict[str, Any]] = Field(default_factory=list) # 图片 (含 caption)
    document_title: str = ""
    metadata: Dict[str, Any] = Field(default_factory=dict)

class BaseDocumentParser(ABC):
    @abstractmethod
    def parse(
        self, 
        filename: str, 
        binary: bytes = None,
        from_page: int = 0, 
        to_page: int = 100000,
        lang: str = "English", 
        callback: Optional[Callable] = None
    ) -> ParseResult:
        """
        从字节流或文件解析文档内容.
        支持分页解析与处理回调.
        """
        pass

    @abstractmethod
    def supported_formats(self) -> List[str]:
        """返回此解析器支持的文件后缀列表."""
        pass

class DocumentParserFactory:
    """
    解析器工厂 (策略模式).
    根据 ParseMethod 动态创建对应的解析器实例.
    """
    _parsers: Dict[ParseMethod, type[BaseDocumentParser]] = {}

    @classmethod
    def register(cls, method: ParseMethod, parser_class: type[BaseDocumentParser]):
        cls._parsers[method] = parser_class

    @classmethod
    def create(cls, method: ParseMethod, **kwargs) -> BaseDocumentParser:
        parser_cls = cls._parsers.get(method)
        if not parser_cls:
            raise ValueError(f"No parser registered for method: {method}")
        return parser_cls(**kwargs)
