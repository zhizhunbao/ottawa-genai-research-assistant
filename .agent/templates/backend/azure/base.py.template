"""
Azure 服务基类和协议定义

定义所有 Azure 服务的通用接口和基类。
"""

from abc import ABC, abstractmethod
from typing import Protocol, TypeVar, Generic, Any
import logging
import asyncio
from functools import wraps

logger = logging.getLogger(__name__)

T = TypeVar("T")


# ============================================
# Protocols (接口定义)
# ============================================

class LLMService(Protocol):
    """LLM 服务协议"""

    async def complete(
        self,
        messages: list[dict[str, str]],
        **kwargs,
    ) -> str:
        """生成聊天回复"""
        ...

    async def embed(self, text: str) -> list[float]:
        """生成文本嵌入向量"""
        ...

    async def stream(
        self,
        messages: list[dict[str, str]],
        **kwargs,
    ):
        """流式生成回复"""
        ...


class SearchService(Protocol):
    """搜索服务协议"""

    async def query(
        self,
        text: str,
        top_k: int = 5,
        filters: dict | None = None,
    ) -> list[dict]:
        """执行搜索"""
        ...

    async def index(self, documents: list[dict]) -> int:
        """索引文档"""
        ...

    async def delete(self, ids: list[str]) -> int:
        """删除文档"""
        ...


class StorageService(Protocol):
    """存储服务协议"""

    async def upload(
        self,
        name: str,
        content: bytes,
        content_type: str = "application/octet-stream",
    ) -> str:
        """上传文件，返回 URL"""
        ...

    async def download(self, name: str) -> bytes | None:
        """下载文件"""
        ...

    async def delete(self, name: str) -> bool:
        """删除文件"""
        ...

    async def exists(self, name: str) -> bool:
        """检查文件是否存在"""
        ...


# ============================================
# Base Class
# ============================================

class AzureServiceBase(ABC):
    """Azure 服务基类"""

    def __init__(self, service_name: str):
        self._service_name = service_name
        self._logger = logging.getLogger(f"azure.{service_name}")

    @property
    def name(self) -> str:
        return self._service_name

    @abstractmethod
    async def health_check(self) -> bool:
        """健康检查"""
        pass

    def _log_operation(self, operation: str, **kwargs):
        """记录操作日志"""
        self._logger.info(
            f"{operation}",
            extra={"service": self._service_name, **kwargs}
        )

    def _log_error(self, operation: str, error: Exception):
        """记录错误日志"""
        self._logger.error(
            f"{operation} failed: {error}",
            extra={"service": self._service_name},
            exc_info=True,
        )


# ============================================
# Retry Decorator
# ============================================

def with_retry(
    max_retries: int = 3,
    base_delay: float = 1.0,
    max_delay: float = 30.0,
    exceptions: tuple = (Exception,),
):
    """
    指数退避重试装饰器

    Args:
        max_retries: 最大重试次数
        base_delay: 基础延迟（秒）
        max_delay: 最大延迟（秒）
        exceptions: 需要重试的异常类型
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e

                    if attempt == max_retries:
                        break

                    delay = min(base_delay * (2 ** attempt), max_delay)
                    logger.warning(
                        f"Retry {attempt + 1}/{max_retries} for {func.__name__} "
                        f"after {delay:.1f}s: {e}"
                    )
                    await asyncio.sleep(delay)

            raise last_exception

        return wrapper
    return decorator


# ============================================
# Result Wrapper
# ============================================

class Result(Generic[T]):
    """操作结果包装器"""

    def __init__(
        self,
        success: bool,
        data: T | None = None,
        error: str | None = None,
    ):
        self.success = success
        self.data = data
        self.error = error

    @classmethod
    def ok(cls, data: T) -> "Result[T]":
        return cls(success=True, data=data)

    @classmethod
    def fail(cls, error: str) -> "Result[T]":
        return cls(success=False, error=error)

    def unwrap(self) -> T:
        """获取数据，失败时抛出异常"""
        if not self.success:
            raise ValueError(self.error)
        return self.data

    def unwrap_or(self, default: T) -> T:
        """获取数据，失败时返回默认值"""
        return self.data if self.success else default
